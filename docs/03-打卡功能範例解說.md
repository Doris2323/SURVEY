# 打卡功能範例解說

這份文件將帶你走過一個完整的 **AI × BDD** 開發週期，從零開始實作一個可運行的打卡 Web App。

## 📖 使用指南

- **👶 想快速上手？** → 直接跳到 [🚀 快速開始：Step-by-Step 完整實作](#-快速開始step-by-step-完整實作)
- **🎓 想理解概念？** → 從 [Part 1：教學範例](#-part-1教學範例---從零開始理解-bdd) 開始
- **💼 想看實戰案例？** → 查看 [Part 2：實戰範例](#-part-2實戰範例---專案實際流程)

---

## 🚀 快速開始：Step-by-Step 完整實作

**目標**：跟著以下步驟，30 分鐘內完成一個可運行的打卡 Web App！

### 前置準備

**所需工具**：
- ✅ Node.js (v18+)
- ✅ Google 帳號
- ✅ AI 助手（Cursor / ChatGPT / Claude）
- ✅ 本專案已下載到本機

**環境檢查**：

```bash
# 1. 確認專案路徑
cd /path/to/workshop_clock_in_v2

# 2. 安裝依賴
npm install

# 3. 檢查測試環境
npm test

# 應該看到：31 scenarios (31 passed)
```

---

### Step 1：理解專案結構（2 分鐘）

```
workshop_clock_in_v2/
├── features/               # Gherkin 規格文件
│   ├── 打卡記錄.feature    # 後端邏輯規格
│   ├── 頁面流程.feature    # 前端 UI 規格
│   └── step_definitions/   # 測試步驟定義（由 AI 產生）
├── src/
│   ├── 程式碼.js           # Apps Script 後端（由 AI 產生）
│   └── Index.html          # 前端頁面（由 AI 產生）
├── prompts/                # AI 提示詞模板
│   ├── 01-Gherkin-to-Step-Definition.md
│   ├── 02-紅燈.md
│   ├── 03-綠燈.md
│   └── 04-重構.md
└── lib/                    # Mock 測試框架
```

**重點**：
- `features/` = 需求規格（人類可讀的文件）
- `src/` = 實際程式碼（AI 幫你產生）
- `prompts/` = 告訴 AI 該做什麼

---

### Step 2：重置專案到初始狀態（1 分鐘）

```bash
# 清除所有程式碼，回到學習起點
npm run reset

# 確認提示，輸入 y
```

**結果**：
- ✅ `features/step_definitions/` 清空
- ✅ `src/程式碼.js` 重置為空白範本
- ✅ `src/Index.html` 刪除

---

### Step 3：產生 Step Definitions（5 分鐘）

**使用 AI 助手**（Cursor / ChatGPT）：

```
do: @prompts/01-Gherkin-to-Step-Definition.md
for: @features/打卡記錄.feature @features/頁面流程.feature
```

**AI 會做什麼**：
1. 讀取 Feature 文件中的所有 Gherkin 場景
2. 產生對應的 Step Definitions（JavaScript 測試程式碼）
3. 建立 Mock 測試環境

**產生的檔案**：
- `features/step_definitions/打卡記錄.steps.js`
- `features/step_definitions/頁面流程.steps.js`

**驗證**：

```bash
npm test
```

**預期結果**：

```
31 scenarios (31 failed)
183 steps (31 failed, 152 skipped)

✖ When 我打卡「OUT」
    TypeError: this.ctx.punch is not a function
```

✅ **紅燈成功！** 測試失敗表示程式碼尚未實作。

---

### Step 4：觀察紅燈（3 分鐘）

**重要觀念**：紅燈是 **TDD 的第一步**，確保測試有效。

**觀察錯誤訊息**：

```bash
npm test | grep "not a function"
```

你應該看到類似的錯誤：

```
this.ctx.punch is not a function
this.ctx.punchAtTime is not a function
this.ctx.getTodayRecords is not a function
this.ctx.getTodayWorkHours is not a function
this.ctx.getWebPageData is not a function
this.ctx.doGet is not a function
```

**解讀**：
- 測試期待這些函式存在
- 但 `src/程式碼.js` 還沒實作
- 這就是我們要讓 AI 完成的工作

---

### Step 5：實作後端邏輯（10 分鐘）

**使用 AI 助手**：

```
do: @prompts/03-綠燈.md
```

**AI 會做什麼**：
1. 分析紅燈錯誤訊息
2. 逐步實作缺少的函式
3. 確保所有測試通過

**實作的函式**：

```javascript
// src/程式碼.js

// 常數定義
const SHEET_NAME = '打卡記錄';
const COLUMN = { UUID: 0, TYPE: 1, TIME: 2, CREATED_AT: 3 };
const PUNCH_TYPE = { IN: 'IN', OUT: 'OUT' };

// 核心功能
function punch(type) { ... }              // 打卡（當前時間）
function punchAtTime(type, time) { ... }  // 打卡（指定時間）
function getTodayRecords() { ... }        // 查詢今日記錄
function getTodayWorkHours() { ... }      // 計算工時
function getWebPageData() { ... }         // Web API

// Web App 入口
function doGet() {
  return HtmlService.createHtmlOutputFromFile('Index');
}

// 輔助函式
function getSheet() { ... }
function getAllRows() { ... }
function isToday(createdAtISO) { ... }
function validatePunchType(type, allRows) { ... }
```

**驗證**：

```bash
npm test
```

**預期結果**：

```
31 scenarios (31 passed)
183 steps (183 passed)
```

✅ **綠燈成功！** 所有測試通過。

---

### Step 6：產生前端頁面（5 分鐘）

目前後端邏輯完成了，但還沒有使用者介面。

**查看目前狀態**：

```bash
ls src/
# 輸出：程式碼.js （還沒有 Index.html）
```

**產生 HTML**（方式 1：直接詢問 AI）：

```
請根據以下需求產生 src/Index.html：

需求：
1. 顯示「打卡系統」標題
2. 顯示兩個按鈕：「IN 上班」、「OUT 下班」
3. 顯示今日打卡記錄列表
4. 顯示累計工時
5. 按鈕點擊時呼叫 google.script.run.punch()
6. 使用 Bootstrap 5 美化樣式

參考 @features/頁面流程.feature 的規格
```

**產生 HTML**（方式 2：執行測試讓 AI 自動產生）：

如果 AI 已經訓練過本專案，執行測試時會自動產生 HTML：

```bash
npm test
```

如果看到與 HTML 相關的測試失敗，AI 會自動產生 `src/Index.html`。

**驗證**：

```bash
npm test
```

確保所有測試仍然通過。

---

### Step 7：重構優化（3 分鐘）

**使用 AI 助手**：

```
do: @prompts/04-重構.md
```

**AI 會做什麼**：
1. 抽取常數（避免魔術數字）
2. 抽取輔助函式（減少重複程式碼）
3. 改善命名（提高可讀性）
4. 確保測試保持綠燈

**重構範例**：

**Before（重構前）**：
```javascript
if (type === 'OUT') {
  for (let i = allRows.length - 1; i >= 1; i--) {
    if (allRows[i][1] === 'IN') {
      hasIN = true;
      break;
    }
  }
}
```

**After（重構後）**：
```javascript
if (type === PUNCH_TYPE.OUT) {
  for (let i = allRows.length - 1; i >= 1; i--) {
    if (allRows[i][COLUMN.TYPE] === PUNCH_TYPE.IN) {
      hasIN = true;
      break;
    }
  }
}
```

**驗證**：

```bash
npm test
```

確保重構後測試仍然全部通過。

---

### Step 8：部署到 Google Apps Script（5 分鐘）

**前置準備**：

1. **建立 Google Sheet**：
   - 前往 https://sheets.google.com
   - 建立新試算表
   - 第一個工作表命名為「打卡記錄」
   - 第一列填入：`UUID | 類型 | 時間 | createdAt`

2. **建立 Apps Script 專案**：
   - 在 Sheet 中：擴充功能 → Apps Script
   - 複製 Script ID（從網址或專案設定中）

3. **設定 clasp**：

```bash
# 編輯 .clasp.json
{
  "scriptId": "<你的 Script ID>",
  "rootDir": "./src",
  "parentId": ["<你的 Spreadsheet ID>"]
}
```

**部署步驟**：

```bash
# 1. 登入 Google 帳號
npx clasp login

# 2. 推送程式碼
npx clasp push

# 3. 部署為 Web App
npx clasp deploy --description "打卡系統 v1.0"

# 4. 開啟 Apps Script 專案
npx clasp open
```

**在 Apps Script 介面中**：

1. 點擊「部署」→「新增部署作業」
2. 類型：選擇「網頁應用程式」
3. 執行身分：選擇「我」
4. 存取權：選擇「所有人」
5. 點擊「部署」
6. 複製「網頁應用程式網址」

**測試 Web App**：

開啟複製的網址，你應該看到：
- ✅ 打卡系統標題
- ✅ IN 上班 / OUT 下班 按鈕
- ✅ 今日打卡記錄列表
- ✅ 累計工時顯示

---

### Step 9：測試完整流程（2 分鐘）

**測試場景 1：上班打卡**
1. 點擊「IN 上班」按鈕
2. 應該看到成功訊息
3. 記錄列表應該顯示 1 筆 IN 記錄

**測試場景 2：下班打卡**
1. 點擊「OUT 下班」按鈕
2. 應該看到成功訊息
3. 記錄列表應該顯示 2 筆記錄
4. 累計工時應該計算正確

**測試場景 3：錯誤驗證**
1. 再次點擊「OUT 下班」按鈕
2. 應該看到錯誤訊息「請先完成 IN 打卡」

---

### Step 10：驗收完成（1 分鐘）

**檢查清單**：

- [ ] 本機測試全部通過（`npm test`）
- [ ] Web App 可以開啟
- [ ] 可以正常打卡（IN/OUT）
- [ ] 顯示今日記錄
- [ ] 計算工時正確
- [ ] 錯誤處理正常（連續打卡/未上班就下班）

**恭喜！** 🎉 你已經完成一個完整的 **AI × BDD** Web App 開發！

---

## 📊 完整流程時間表

| 步驟 | 任務 | 預估時間 | 累計時間 |
|------|------|---------|---------|
| 1 | 理解專案結構 | 2 分鐘 | 2 分鐘 |
| 2 | 重置專案 | 1 分鐘 | 3 分鐘 |
| 3 | 產生 Step Definitions | 5 分鐘 | 8 分鐘 |
| 4 | 觀察紅燈 | 3 分鐘 | 11 分鐘 |
| 5 | 實作後端邏輯 | 10 分鐘 | 21 分鐘 |
| 6 | 產生前端頁面 | 5 分鐘 | 26 分鐘 |
| 7 | 重構優化 | 3 分鐘 | 29 分鐘 |
| 8 | 部署 GAS | 5 分鐘 | 34 分鐘 |
| 9 | 測試流程 | 2 分鐘 | 36 分鐘 |
| 10 | 驗收完成 | 1 分鐘 | 37 分鐘 |

**總計**：約 **30-40 分鐘**完成！

---

## 💡 常見問題 FAQ

### Q1：測試一直失敗怎麼辦？

**A**：檢查以下項目：
1. `npm install` 是否成功？
2. Node.js 版本是否 v18+？
3. 是否在正確的目錄下執行？
4. 重新執行 `npm run reset` 清除狀態

### Q2：AI 產生的程式碼不對怎麼辦？

**A**：
1. 確認你提供的 Prompt 正確（使用 `@prompts/` 中的範本）
2. 提供更多 context（如 `@features/` 檔案）
3. 明確指出錯誤訊息，讓 AI 修正

### Q3：部署後 Web App 打不開？

**A**：
1. 檢查部署設定：執行身分 = 「我」，存取權 = 「所有人」
2. 確認 `.clasp.json` 中的 Script ID 正確
3. 檢查 Google Sheet 工作表名稱是否為「打卡記錄」

### Q4：我想添加新功能怎麼做？

**A**：參考 [04-如何新增自己的功能.md](./04-如何新增自己的功能.md)

---

## 🎯 下一步學習路徑

完成快速開始後，建議你：

1. **深入理解 BDD**：閱讀下方的 [Part 1：教學範例](#-part-1教學範例---從零開始理解-bdd)
2. **研究實戰技巧**：閱讀 [Part 2：實戰範例](#-part-2實戰範例---專案實際流程)
3. **完成練習題**：挑戰 [動手練習](#-動手練習) 章節
4. **添加新功能**：閱讀 [04-如何新增自己的功能.md](./04-如何新增自己的功能.md)

---

## 🎓 Part 1：教學範例 - 從零開始理解 BDD

## 📚 Part 1：教學範例 - 從零開始理解 BDD

### 目標功能（簡化版）

我們從最簡單的場景開始：

```gherkin
Scenario: 新增上班打卡
  When 我執行「IN」打卡
  Then 打卡結果應該成功
  And 工作表應該有 1 筆記錄
```

**白話文**：按下「上班打卡」按鈕，系統應該成功記錄。

---

### 步驟 1：綁定測試（產生 Step Definitions）

在真實專案中，你會使用 AI 來產生：

```
do: @prompts/01-Gherkin-to-Step-Definition.md
for: @features/打卡記錄.feature
```

產生的 Step Definition 會長這樣：

```javascript
// features/step_definitions/打卡.steps.js

import { Given, When, Then } from '@cucumber/cucumber';
import { strict as assert } from 'assert';

When('我執行「{word}」打卡', function(type) {
  // 呼叫尚未實作的函式
  this.result = ctx.punch(type);
});

Then('打卡結果應該成功', function() {
  assert.ok(this.result?.success, '打卡應該成功');
});

Then('工作表應該有 {int} 筆記錄', function(expectedCount) {
  const sheet = ctx._getSheet('打卡記錄');
  const data = sheet.getDataRange().getValues();
  const actualCount = data.length - 1; // 扣掉標題列
  assert.strictEqual(actualCount, expectedCount);
});
```

**重點**：
- `When` 步驟呼叫 `ctx.punch(type)` - **這個函式還不存在！**
- `Then` 步驟驗證結果

---

### 步驟 2：紅燈（測試失敗）

執行測試：

```bash
npm test
```

**預期結果**：

```
Scenario: 新增上班打卡
  ✖ When 我執行「IN」打卡
      TypeError: ctx.punch is not a function
  - Then 打卡結果應該成功
  - And 工作表應該有 1 筆記錄

1 scenario (1 failed)
3 steps (1 failed, 2 skipped)
```

**解讀**：
- `✖` 紅燈失敗：`punch` 函式不存在
- `-` 跳過：因為前一步失敗了

✅ **這就是紅燈！** 測試正確偵測到缺失的實作。

---

### 步驟 3：綠燈（最小實作）

現在寫**最少的程式碼**讓測試通過：

```javascript
// src/程式碼.js

/**
 * 執行打卡
 */
function punch(type) {
  const sheet = SpreadsheetApp.getActiveSpreadsheet()
    .getSheetByName('打卡記錄');
  
  // 產生記錄
  const uuid = Utilities.getUuid();
  const now = new Date();
  
  // 新增到工作表
  sheet.appendRow([uuid, type, now, now]);
  
  return { success: true };
}
```

**再次執行測試**：

```bash
npm test
```

**結果**：

```
Scenario: 新增上班打卡
  ✔ When 我執行「IN」打卡
  ✔ Then 打卡結果應該成功
  ✔ And 工作表應該有 1 筆記錄

1 scenario (1 passed)
3 steps (3 passed)
```

✅ **綠燈！** 所有測試通過。

---

### 步驟 4：重構（改善品質）

現在程式碼能運作，但可以改善：

```javascript
// src/程式碼.js

const SHEET_NAME = '打卡記錄';
const PUNCH_TYPE = { IN: 'IN', OUT: 'OUT' };

function punch(type) {
  // 驗證類型
  if (!Object.values(PUNCH_TYPE).includes(type)) {
    return { success: false, message: '無效的打卡類型' };
  }
  
  const sheet = getSheet();
  const uuid = Utilities.getUuid();
  const now = new Date();
  
  sheet.appendRow([uuid, type, now, now]);
  
  return { success: true };
}

function getSheet() {
  return SpreadsheetApp.getActiveSpreadsheet()
    .getSheetByName(SHEET_NAME);
}
```

**改善了什麼？**
- ✅ 抽取常數（`SHEET_NAME`, `PUNCH_TYPE`）
- ✅ 驗證輸入參數
- ✅ 抽取輔助函式（`getSheet`）

**確認測試仍然通過**：

```bash
npm test  # 應該還是綠燈
```

---

## 🎯 完整 BDD 週期總結

```
┌────────────────────────────────────────────────────────────┐
│                                                            │
│   1. Feature        2. 紅燈         3. 綠燈       4. 重構  │
│   ┌─────────┐      ┌─────────┐     ┌─────────┐   ┌─────┐ │
│   │ Gherkin │ ──→  │  測試   │ ──→ │  實作   │ ──│ 改善│ │
│   │  規格   │      │  失敗   │     │  通過   │   │ 品質│ │
│   └─────────┘      └─────────┘     └─────────┘   └─────┘ │
│        │                                            │      │
│        └──────────────── 下一個場景 ←───────────────┘      │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

---

## 💼 Part 2：實戰範例 - 專案實際流程

現在讓我們看看**真實專案**中的完整範例。

### 為什麼實際專案從「錯誤處理」開始？

在真實開發中，我們通常會：

1. ✅ **先寫驗證規則**（防止錯誤操作）
2. ✅ **再寫正常流程**（基本功能）
3. ✅ **最後處理邊界情況**

這樣的順序能確保系統**健壯性優先**。

---

### 實際 Feature 文件結構

打開 `features/打卡記錄.feature`，你會看到：

```gherkin
Feature: 打卡記錄
  作為一個員工
  我想要記錄上下班打卡時間
  以便追蹤我的工作時數

  Background:
    Given 系統已準備好「打卡記錄」工作表

  # ========== 前置條件 - 參數驗證 ==========

  Rule: 前置條件 - 必須先有 IN 記錄才能打 OUT（否則失敗）

    Example: 未上班就下班應失敗
      Given 今日無打卡記錄
      When 我打卡「OUT」
      Then 打卡結果應該失敗
      And 錯誤訊息應包含「請先完成 IN 打卡」

  # ========== 後置條件 ==========

  Rule: 後置條件 - 無記錄時打 IN 應新增一筆 IN 記錄

    Example: 新增上班打卡記錄
      When 我在「2026/1/27上午9:00:00」打卡「IN」
      Then 打卡結果應該成功
      And 工作表應該有 1 筆記錄
      And 最新記錄的類型應該是「IN」
      And 最新記錄的時間應該是「2026/1/27上午9:00:00」
```

**關鍵差異**：

| 項目 | 教學範例 | 實際專案 |
|------|---------|---------|
| **第一個測試** | 正常流程 | 錯誤驗證 |
| **步驟語法** | `我執行「IN」打卡` | `我在「時間」打卡「IN」` |
| **工作表欄位** | `ID, 類型, 時間, 建立時間` | `UUID, 類型, 時間, createdAt` |
| **測試前置** | 簡化 | 完整測試隔離（Before hook） |

---

### 實際 Step Definitions（完整版）

打開 `features/step_definitions/打卡記錄.steps.js`：

```javascript
import { Given, When, Then, Before, After } from '@cucumber/cucumber';
import { strict as assert } from 'assert';
import { loadGasCodeForTesting } from '../../lib/gas-loader.js';

let ctx;

Before(function() {
  // 初始化測試環境
  ctx = loadGasCodeForTesting({
    sheets: {
      '打卡記錄': ['UUID', '類型', '時間', 'createdAt']
    }
  });
  
  // ⚠️ 重要：測試隔離
  // 確保每個 Scenario 開始時，工作表只有標題列
  const sheet = ctx.SpreadsheetApp.getActiveSpreadsheet()
    .getSheetByName('打卡記錄');
  const data = sheet.getDataRange().getValues();
  
  if (data.length > 1) {
    sheet.deleteRows(2, data.length - 1);
  }
  
  this.ctx = ctx;
});

After(function() {
  ctx._clearAllSheets();
});

// Given 步驟

Given('今日無打卡記錄', function() {
  const sheet = this.ctx.SpreadsheetApp.getActiveSpreadsheet()
    .getSheetByName('打卡記錄');
  const data = sheet.getDataRange().getValues();
  assert.strictEqual(data.length, 1, '應該只有標題列');
});

Given(/^已有一筆打卡記錄：類型「(.+)」時間「(.+)」$/, function(type, time) {
  const sheet = this.ctx.SpreadsheetApp.getActiveSpreadsheet()
    .getSheetByName('打卡記錄');
  const uuid = 'test-uuid-' + Date.now();
  const now = new Date();
  
  // ⚠️ createdAt 使用 ISO 格式，用於判斷「今日記錄」
  const createdAt = now.toISOString();
  
  sheet.appendRow([uuid, type, time, createdAt]);
});

// When 步驟

When(/^我在「(.+)」打卡「(.+)」$/, function(time, type) {
  try {
    this.result = this.ctx.punchAtTime(type, time);
  } catch (error) {
    this.error = error;
  }
});

// Then 步驟

Then('打卡結果應該失敗', function() {
  assert.ok(
    this.error || !this.result?.success,
    '打卡應該失敗'
  );
});

Then(/^錯誤訊息應包含「(.+)」$/, function(expectedMessage) {
  const actualMessage = this.error?.message || this.result?.message || '';
  assert.ok(
    actualMessage.includes(expectedMessage),
    `錯誤訊息應包含 "${expectedMessage}"，實際為 "${actualMessage}"`
  );
});
```

**重點說明**：

1. **Before Hook**：確保每個測試開始時狀態一致
2. **createdAt 欄位**：用 ISO 格式儲存建立時間，準確判斷「今日記錄」
3. **錯誤處理**：用 `try-catch` 捕捉實作函式可能拋出的錯誤

---

### 實際執行流程

#### 1. 產生 Step Definitions

```
do: @prompts/01-Gherkin-to-Step-Definition.md
for: @features/打卡記錄.feature
```

AI 會根據 Feature 文件產生完整的 Step Definitions。

---

#### 2. 紅燈測試

```bash
npm test
```

**結果**（首次執行）：

```
Feature: 打卡記錄

  Scenario: 未上班就下班應失敗
    ✔ Given 系統已準備好「打卡記錄」工作表
    ✔ Given 今日無打卡記錄
    ✖ When 我打卡「OUT」
        TypeError: this.ctx.punch is not a function
    - Then 打卡結果應該失敗
    - And 錯誤訊息應包含「請先完成 IN 打卡」

  Scenario: 新增上班打卡記錄
    ✔ Given 系統已準備好「打卡記錄」工作表
    ✖ When 我在「2026/1/27上午9:00:00」打卡「IN」
        TypeError: this.ctx.punchAtTime is not a function
    - Then 打卡結果應該成功
    - And 工作表應該有 1 筆記錄

31 scenarios (31 failed)
183 steps (31 failed, 152 skipped)
```

所有場景都失敗了，因為 `punch()` 和 `punchAtTime()` 函式還沒實作。

---

#### 3. 綠燈實作

```
do: @prompts/03-綠燈.md
```

AI 會實作必要的函式：

```javascript
// src/程式碼.js

const SHEET_NAME = '打卡記錄';
const COLUMN = {
  UUID: 0,
  TYPE: 1,
  TIME: 2,
  CREATED_AT: 3
};
const PUNCH_TYPE = {
  IN: 'IN',
  OUT: 'OUT'
};

/**
 * 執行打卡（使用當前時間）
 */
function punch(type) {
  const allRows = getAllRows();
  
  // 驗證打卡類型
  const validation = validatePunchType(type, allRows);
  if (!validation.valid) {
    return { success: false, message: validation.message };
  }
  
  const sheet = getSheet();
  const uuid = Utilities.getUuid();
  const now = new Date();
  const timeStr = formatChinaDateTime(now);
  
  sheet.appendRow([uuid, type, timeStr, now.toISOString()]);
  
  return { success: true, message: '打卡成功' };
}

/**
 * 在指定時間打卡
 */
function punchAtTime(type, time) {
  const allRows = getAllRows();
  
  // 驗證打卡類型
  const validation = validatePunchType(type, allRows);
  if (!validation.valid) {
    return { success: false, message: validation.message };
  }
  
  // 驗證時間規則（略）
  
  const sheet = getSheet();
  const uuid = Utilities.getUuid();
  const now = new Date();
  
  sheet.appendRow([uuid, type, time, now.toISOString()]);
  
  return { success: true, message: '打卡成功' };
}

/**
 * 驗證打卡類型是否合法
 */
function validatePunchType(type, allRows) {
  // 驗證：未上班就下班
  if (type === PUNCH_TYPE.OUT) {
    let hasIN = false;
    for (let i = allRows.length - 1; i >= 1; i--) {
      if (allRows[i][COLUMN.TYPE] === PUNCH_TYPE.IN) {
        hasIN = true;
        break;
      } else if (allRows[i][COLUMN.TYPE] === PUNCH_TYPE.OUT) {
        break;
      }
    }
    if (!hasIN) {
      return { valid: false, message: '請先完成 IN 打卡' };
    }
  }
  
  // 驗證：連續上班
  if (type === PUNCH_TYPE.IN && allRows.length > 1) {
    const lastRow = allRows[allRows.length - 1];
    if (lastRow[COLUMN.TYPE] === PUNCH_TYPE.IN) {
      return { valid: false, message: '請先完成 OUT 打卡' };
    }
  }
  
  return { valid: true };
}

// 輔助函式
function getSheet() {
  return SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_NAME);
}

function getAllRows() {
  return getSheet().getDataRange().getValues();
}
```

**再次測試**：

```bash
npm test
```

**結果**：

```
31 scenarios (31 passed)
183 steps (183 passed)
```

✅ **全綠！** 所有測試通過。

---

#### 4. 重構改善

```
do: @prompts/04-重構.md
```

重構的改進：

- ✅ **抽取常數**：`COLUMN`, `PUNCH_TYPE`
- ✅ **抽取日期邏輯**：`getTodayDateRange()`, `isToday()`
- ✅ **抽取驗證邏輯**：`validatePunchType()`
- ✅ **抽取工作表操作**：`getAllRows()`, `getLastRecord()`

**確認測試保持綠燈**：

```bash
npm test  # 應該還是全部通過
```

---

## 📊 教學範例 vs 實戰範例對比

| 維度 | 教學範例 🎓 | 實戰範例 💼 |
|------|------------|------------|
| **目的** | 理解概念 | 實際應用 |
| **複雜度** | 簡化（3 個步驟） | 完整（183 個步驟） |
| **測試順序** | 正常流程優先 | 錯誤驗證優先 |
| **Mock 設定** | 簡化 | 完整測試隔離 |
| **實作策略** | 最小可行 | 考慮錯誤處理 |
| **適用場景** | 學習 BDD 流程 | 真實專案開發 |

---

## ✋ 動手練習

### 🎯 練習 1：完成「新增下班打卡」

參考 `features/打卡記錄.feature` 中的場景：

```gherkin
Example: 新增下班打卡記錄
  Given 已有一筆打卡記錄：類型「IN」時間「2026/1/27上午9:00:00」
  When 我在「2026/1/27下午6:00:00」打卡「OUT」
  Then 打卡結果應該成功
  And 工作表應該有 2 筆記錄
  And 最新記錄的類型應該是「OUT」
  And 最新記錄的時間應該是「2026/1/27下午6:00:00」
```

**任務**：
1. 執行 `npm test`，觀察這個場景的測試結果
2. 如果失敗，分析錯誤訊息
3. 確認 `punchAtTime()` 函式是否已正確實作

---

### 🎯 練習 2：理解測試隔離

在 `features/step_definitions/打卡記錄.steps.js` 中找到 `Before` hook。

**問題**：
1. 為什麼每個測試前要清空工作表？
2. 如果不清空會發生什麼問題？
3. 試著註解掉清空邏輯，執行測試看看會發生什麼

---

### 🎯 練習 3：添加新功能

嘗試添加一個新場景：**查詢今日工時**

```gherkin
Example: 計算今日工時
  Given 已有一筆打卡記錄：類型「IN」時間「2026/1/27上午9:00:00」
  And 已有一筆打卡記錄：類型「OUT」時間「2026/1/27下午6:00:00」
  When 我查詢今日工時
  Then 工時應該是 540 分鐘
```

**步驟**：
1. 在 Feature 文件中添加場景
2. 執行 `npm test` 看到紅燈（步驟未定義）
3. 使用 AI 產生 Step Definitions
4. 實作 `getTodayWorkHours()` 函式
5. 執行測試確認綠燈

---

### 🎯 練習 4：故障排查

**常見錯誤情境**：

#### 錯誤 1：測試總是失敗
```
AssertionError: 工作表應該有 1 筆記錄，實際為 2
```

**可能原因**：
- 沒有正確清空測試資料
- Before hook 沒有執行
- 上一個測試的資料殘留

**解決方法**：檢查 Before/After hooks

---

#### 錯誤 2：函式未定義
```
TypeError: this.ctx.punch is not a function
```

**可能原因**：
- 函式名稱拼錯
- 函式沒有被 export
- Mock 沒有正確載入函式

**解決方法**：
1. 檢查 `src/程式碼.js` 是否有定義函式
2. 確認函式名稱一致
3. 檢查 `lib/gas-loader.js` 是否正確載入

---

#### 錯誤 3：Date 格式不符
```
AssertionError: 時間應為 "2026/1/27上午9:00:00"，實際為 "Tue Jan 27 2026..."
```

**可能原因**：
- Google Sheets 自動將字串轉為 Date 物件

**解決方法**：
- 在 Step Definition 中處理 Date 物件
- 使用 `formatChinaDateTime()` 轉換格式

---

## 🚀 進階挑戰

完成基礎練習後，嘗試這些挑戰：

### Challenge 1：多輪打卡
```gherkin
Example: 計算多輪打卡的工時
  Given 已有以下打卡記錄：
    | 類型 | 時間                  |
    | IN   | 2026/1/27上午9:00:00  |
    | OUT  | 2026/1/27下午12:00:00 |
    | IN   | 2026/1/27下午1:00:00  |
    | OUT  | 2026/1/27下午6:00:00  |
  When 我查詢今日工時
  Then 工時應該是 480 分鐘
```

### Challenge 2：跨日打卡
```gherkin
Example: 跨夜加班工時計算
  Given 已有一筆打卡記錄：類型「IN」時間「2026/1/27下午10:00:00」
  And 已有一筆打卡記錄：類型「OUT」時間「2026/1/28上午2:00:00」
  When 我查詢今日工時
  Then 工時應該是 240 分鐘
```

### Challenge 3：HTML 頁面驗證

參考 `features/頁面流程.feature`，實作網頁顯示邏輯：

```gherkin
Example: 開啟打卡頁面顯示今日記錄
  Given 已有一筆打卡記錄：類型「IN」時間「2026/1/27上午9:00:00」
  When 我開啟打卡頁面
  Then 頁面應該顯示「打卡系統」標題
  And 頁面應該有「OUT 下班」按鈕
  And 頁面應該顯示 1 筆打卡記錄
```

**提示**：需要實作 `doGet()` 函式和 `src/Index.html`。

---

## 📚 下一步

1. **閱讀完整 Feature 文件**：`features/打卡記錄.feature`
2. **研究 Step Definitions**：`features/step_definitions/打卡記錄.steps.js`
3. **查看實作程式碼**：`src/程式碼.js`
4. **學習如何新增功能**：[04-如何新增自己的功能.md](./04-如何新增自己的功能.md)

---

## 💡 重要觀念總結

### BDD 的核心價值

1. **先寫規格**：Feature 文件就是可執行的需求文件
2. **測試驅動**：紅燈 → 綠燈 → 重構的循環
3. **持續驗證**：每次改動都確保測試通過
4. **活文件**：測試即文件，永遠與程式碼同步

### 為什麼從錯誤處理開始？

在實戰中，**防禦性程式設計**很重要：

1. **安全第一**：防止錯誤操作破壞資料
2. **用戶體驗**：提供清楚的錯誤訊息
3. **系統穩定**：確保邊界情況都有處理
4. **降低風險**：錯誤路徑往往是最容易被忽略的

### 測試隔離的重要性

每個測試應該：
- ✅ 獨立執行（不依賴其他測試）
- ✅ 可重複執行（每次結果相同）
- ✅ 快速回饋（幾秒內完成）

---

## 🎓 學習路徑建議

1. **初學者**：從教學範例開始，理解 BDD 基本概念
2. **進階者**：研究實戰範例，學習完整的開發流程
3. **高手**：完成挑戰題，並嘗試添加自己的功能

記住：**BDD 不只是測試工具，而是一種思考方式**！

祝你學習順利！🚀
