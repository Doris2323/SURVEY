# Apps Script BDD 測試架構決策文件

## 概述

本文件記錄 Apps Script BDD 測試架構的關鍵技術決策。

---

## ADR-001: 選擇 Cucumber.js 作為 BDD 框架

### 狀態
已採用

### 背景
需要一個支援 Gherkin 語法的 BDD 測試框架，讓非技術人員也能理解測試案例。

### 決策
使用 Cucumber.js 作為 BDD 測試框架。

### 理由
- 支援中文 Gherkin 語法（功能、場景、假設、當、那麼）
- 與 Node.js 生態系整合良好
- 社群活躍，文件完整
- 支援 Before/After hooks 進行測試前後處理

### 後果
- 學員需要學習 Gherkin 語法
- 需要撰寫 Step Definitions 對應 Feature 檔案

---

## ADR-002: 使用 Node.js VM 沙箱執行 Apps Script

### 狀態
已採用

### 背景
Apps Script 程式碼是設計在 Google 環境執行的，無法直接在本地 Node.js 環境執行。

### 決策
使用 Node.js 內建的 `vm` 模組建立沙箱環境，注入 Mock 的 Google API。

### 理由
- 不需要額外的轉譯工具
- 可以精確控制沙箱中可用的 API
- 執行速度快
- 程式碼不需要修改即可測試

### 後果
- 需要 Mock 所有用到的 Google API
- 某些 Node.js 原生功能（如 require）在沙箱中不可用
- 需要處理全域變數的導出

### 實作
```javascript
import vm from 'vm';

const sandbox = {
  SpreadsheetApp,  // Mock
  Utilities,       // Mock
  // ... 其他 Mock API
};

const context = vm.createContext(sandbox);
vm.runInContext(gasCode, context);
```

---

## ADR-003: Mock 策略

### 狀態
已採用

### 背景
需要模擬 Google Apps Script 提供的各種 API。

### 決策
建立一套可配置的 Mock 物件，模擬常用的 Google API。

### Mock 清單
| Mock 物件 | 模擬目標 | 用途 |
|-----------|----------|------|
| `createMockSpreadsheet()` | Spreadsheet | 試算表操作 |
| `createMockSheet()` | Sheet | 工作表操作 |
| `createMockSpreadsheetApp()` | SpreadsheetApp | 全域 API |
| `createMockUtilities()` | Utilities | 工具函式 |
| `createMockSession()` | Session | 使用者資訊 |
| `createMockHtmlService()` | HtmlService | HTML 輸出 |
| `createMockContentService()` | ContentService | 內容輸出 |
| `createMockPropertiesService()` | PropertiesService | 屬性儲存 |
| `createMockLogger()` | Logger | 日誌記錄 |
| `createMockGoogleScriptRun()` | google.script.run | 前端呼叫後端 |

### 設計原則
1. **可配置**：標題列、初始資料等可透過參數設定
2. **測試友善**：提供 `_` 開頭的測試輔助方法（如 `_getData()`）
3. **動態代理**：使用 Proxy 處理未預期的方法呼叫
4. **模擬真實行為**：序列化限制等邊界情況也要模擬

### 特殊 Mock 行為

#### getValues() vs getDisplayValues()
```javascript
// getValues() 會將日期時間字串轉為 Date 物件（模擬真實 GAS）
sheet.getDataRange().getValues()
// → [['id', 'IN', Date Object, Date Object]]

// getDisplayValues() 回傳字串（安全）
sheet.getDataRange().getDisplayValues()
// → [['id', 'IN', '2026-01-21 12:00:00', '2026-01-21 12:00:00']]
```

#### google.script.run 序列化檢查
Mock 會檢查回傳值是否包含無法序列化的內容：

```javascript
// 預設模式：模擬真實行為（回傳 null + console 警告）
createMockGoogleScriptRun(gasContext)

// 嚴格模式：拋出錯誤讓測試失敗（推薦用於開發）
createMockGoogleScriptRun(gasContext, { strictMode: true })
```

檢查項目：
- `Date` 物件 → 建議使用 `getDisplayValues()`
- `NaN` → 建議加入 `isNaN()` 檢查

---

## ADR-004: Feature 檔案組織方式

### 狀態
已採用

### 背景
需要決定如何組織 Feature 檔案和 Step Definitions。

### 決策
```
features/
├── 功能A.feature          # 業務功能 Feature
├── 功能B.feature
├── 頁面流程.feature       # E2E 測試（@e2e 標籤）
└── step_definitions/
    ├── 功能A.steps.js     # 對應的步驟定義
    ├── 功能B.steps.js
    └── common.steps.js    # 共用步驟
```

### 理由
- Feature 檔案按業務功能分類
- Step Definitions 與 Feature 一對一對應
- 共用步驟放在 common.steps.js

### 標籤使用
- `@e2e`：需要前端互動的測試
- `@wip`：開發中的測試
- `@skip`：暫時跳過的測試

---

## ADR-005: 測試上下文管理

### 狀態
已採用

### 背景
每個測試場景需要獨立的測試環境，避免測試之間互相影響。

### 決策
使用 Cucumber.js 的 `Before` hook，在每個場景前重新載入測試環境。

### 實作
```javascript
import { Before } from '@cucumber/cucumber';
import { loadGasCodeForTesting } from '../../lib/gas-loader.js';

let ctx;

Before(function() {
  ctx = loadGasCodeForTesting({
    sheets: {
      '工作表名稱': ['欄位1', '欄位2', '欄位3']
    }
  });
});
```

### 理由
- 每個場景有乾淨的初始狀態
- Mock 物件在場景間不會累積髒資料
- 可以針對不同場景設定不同的初始狀態

---

## ADR-006: 設定檔設計

### 狀態
已採用

### 背景
需要一個方式讓使用者配置測試環境。

### 決策
使用 `specify.config.js` 作為設定檔。

### 設定項目
```javascript
export default {
  // Apps Script 原始碼目錄
  srcDir: 'src',

  // 要導出的函式名稱（可選，不指定則自動偵測）
  exports: ['myFunction'],

  // 初始工作表設定
  sheets: {
    '工作表名稱': ['欄位1', '欄位2']
  }
};
```

### 理由
- JavaScript 格式，可以包含動態邏輯
- ES Module 格式，與專案一致
- 明確的設定項目，易於理解

---

## ADR-007: google.script.run 序列化限制

### 狀態
已採用

### 背景
Web App 透過 `google.script.run` 呼叫後端函式時，回傳值必須能被序列化為 JSON。

### 問題
以下情況會導致 `google.script.run` 回傳 `null`，且**不會拋出錯誤**：
1. 回傳值包含 `Date` 物件
2. 回傳值包含 `NaN`
3. 回傳值包含無法序列化的物件

### 決策
1. **永遠使用 `getDisplayValues()` 而非 `getValues()`**
   - `getValues()` 會回傳 Date 物件，無法序列化
   - `getDisplayValues()` 回傳字串，安全

2. **數值計算加 NaN 檢查**
   ```javascript
   let workHours = calculateWorkHours(records);
   if (isNaN(workHours)) {
     workHours = 0;
   }
   ```

3. **前端直接顯示時間字串，不要用 new Date() 轉換**
   ```javascript
   // ❌ 錯誤：會產生 Invalid Date
   const time = new Date(r.time).toLocaleTimeString();

   // ✅ 正確：直接顯示
   const time = r.time;
   ```

### 除錯技巧
當 `google.script.run` 回傳 `null` 時：
1. 先用簡單測試函式確認連線正常
2. 逐步排除：先不計算，只回傳原始資料
3. 檢查是否有 Date 物件或 NaN

### 範例：安全的回傳結構
```javascript
function getRecordsForWeb() {
  try {
    const records = getTodayRecords();  // 使用 getDisplayValues()
    let workHours = calculateWorkHours(records);

    // NaN 防護
    if (isNaN(workHours)) {
      workHours = 0;
    }

    return {
      records: records,  // 純字串陣列
      workHours: Math.round(workHours * 10) / 10  // 數字
    };
  } catch (e) {
    return {
      error: true,
      message: e.message,
      records: [],
      workHours: 0
    };
  }
}
```

---

## ADR-008: 獨立腳本 vs 綁定腳本

### 狀態
已採用

### 背景
Apps Script 有兩種部署方式：
- **綁定腳本**：附加在特定試算表上
- **獨立腳本**：獨立存在，可連接多個試算表

### 問題
獨立腳本中 `SpreadsheetApp.getActiveSpreadsheet()` 會回傳 `null`。

### 決策
使用 `SpreadsheetApp.openById(SPREADSHEET_ID)` 明確指定試算表。

```javascript
// ❌ 獨立腳本中會回傳 null
const ss = SpreadsheetApp.getActiveSpreadsheet();

// ✅ 使用明確的 ID
const SPREADSHEET_ID = '1bze...';
const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
```

### OAuth Scope
需要在 `appsscript.json` 加入權限：
```json
{
  "oauthScopes": [
    "https://www.googleapis.com/auth/spreadsheets"
  ]
}
```

---

## ADR-009: 中文日期格式處理

### 狀態
已採用

### 背景
Google Sheets 在台灣地區會顯示中文日期格式，如 `2026/1/19 下午 4:44:36`。

### 問題
JavaScript 的 `new Date()` 無法解析中文日期格式。

### 決策
建立 `parseTime()` 函式處理中文格式：

```javascript
function parseTime(timeStr) {
  // 處理中文格式：2026/1/19 下午 4:44:36
  if (timeStr.includes('上午') || timeStr.includes('下午')) {
    const isPM = timeStr.includes('下午');
    const cleaned = timeStr.replace('上午', '').replace('下午', '').trim();
    const [datePart, timePart] = cleaned.split(' ');
    const [year, month, day] = datePart.split('/').map(Number);
    const [hour, minute, second] = timePart.split(':').map(Number);

    let hour24 = hour;
    if (isPM && hour !== 12) hour24 = hour + 12;
    if (!isPM && hour === 12) hour24 = 0;

    return new Date(year, month - 1, day, hour24, minute, second);
  }

  // 標準格式直接解析
  return new Date(timeStr);
}
```

---

## 附錄：常見問題

### Q1: 如何測試需要真實 Google API 的功能？
A: 這套架構專注於單元測試和整合測試。需要真實 API 的測試應該在 Google Apps Script 編輯器中執行。

### Q2: Mock 沒有涵蓋到的 API 怎麼辦？
A: 可以在 `gas-mock.js` 中擴充，或在測試中手動注入。

### Q3: 如何處理非同步操作？
A: 大部分 Apps Script API 是同步的。Mock 的 `google.script.run` 使用 `setTimeout` 模擬非同步行為。

### Q4: google.script.run 回傳 null 怎麼辦？
A: 參考 ADR-007。檢查回傳值是否包含：
- Date 物件（用 `getDisplayValues()` 取代 `getValues()`）
- NaN（加入 `isNaN()` 檢查）
- 無法序列化的物件

### Q5: 獨立腳本無法存取試算表怎麼辦？
A: 參考 ADR-008。使用 `openById()` 並確認 OAuth scope 已設定。
